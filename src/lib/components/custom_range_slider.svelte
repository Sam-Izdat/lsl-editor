<script lang="ts">
  // Slots:
  /** @slot trail - A label slot directly below the range slider. */

  import { afterUpdate, onMount, onDestroy, tick } from 'svelte';

  // Props
  /**
   * Required. Set a unique name for the input.
   * @type {string}
   */
  export let name: string;
  /**
   * Provide a unique input id. Auto-generated by default
   * @type {string}
   */
  export let id = String(Math.random());
  /** Set the input value. */
  export let value = 0;
  /** Set the input minimum range. */
  export let min = 0;
  /** Set the input maximum range. */
  export let max = 100;
  /** Set the input step offset. */
  export let step = 1;
  /** Enables tick marks. See browser support below. */
  export let ticked = false;

  export let valueParsed = '';

  // Props (styles)
  /** Provide classes to set the input accent color. */
  export let accent = 'accent-surface-900 dark:accent-surface-50';

  // Props (a11y)
  /** A semantic ARIA label. */
  export let label = '';

  // Base Styles
  const cBase = 'space-y-1';
  const cBaseLabel = '';
  const cBaseContent = 'flex justify-center py-0';
  const cBaseInput = 'w-full h-2';

  // Local
  let tickmarks: any[];

  // Tickmarks - generate datalist options based on min/max values
  function setTicks(): void {
    if (ticked == false) return;
    tickmarks = Array.from({ length: max - min + 1 }, (_, i) => i + min);
  }

  // Lifecycle
  if (ticked) setTicks();
  afterUpdate(() => {
    setTicks();
  });

  // Reactive Classes
  $: classesBase = `${cBase} ${$$props.class ?? ''}`;
  $: classesInput = `${cBaseInput} ${accent}`;

  // Prune $$restProps to avoid overwriting $$props.class
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }

  let inputRef: HTMLInputElement;
  let sliderRef: HTMLInputElement;
  let isEditing = false;
  let valueAtEditStart = value;

  let controlPressed = false;

  function handleKeydown(event: KeyboardEvent) {
    if (event.key === 'Control') {
      controlPressed = true;
    }

    if (event.key === 'Escape' && isEditing) {
      cancelEdit(); 
    }
  }

  function handleKeyup(event: KeyboardEvent) {
    // Detect when the Control key is released
    if (event.key === 'Control') {
      controlPressed = false;
    }
  }

  async function cancelEdit() {
      value = valueAtEditStart;
      valueParsed = value;
      await tick();
      inputRef.blur();
  }

  function toggleEdit() {
    isEditing = isEditing ? false : (controlPressed ? true : false);
    if (!isEditing) {
      value = Math.max(min, Math.min(max, value));
    } else {      
      valueAtEditStart = value;
    }
  }

  afterUpdate(() => {
    if (isEditing && inputRef) inputRef.focus();
  });

  async function handleValueChange(event: Event) {
    const inputValue = parseFloat((event.target as HTMLInputElement).value);
    if (!isNaN(inputValue)) {
      value = Math.max(min, Math.min(max, inputValue));
    }
    toggleEdit();
    await tick(); 
    sliderRef.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
  }

  function selectValue(event: Event) {
    const inputElement = event.target as HTMLInputElement;
    inputElement.select(); 
  }

  onMount(() => {
    window.addEventListener('keydown', handleKeydown);
    window.addEventListener('keyup', handleKeyup);
  });

  onDestroy(() => {
    window.removeEventListener('keydown', handleKeydown);
    window.removeEventListener('keyup', handleKeyup);
  });
</script>

<div class="range-slider {classesBase}" data-testid="range-slider">
  <!-- Slot: Default -->
  {#if $$slots.default || label}
    <label class="range-slider-label {cBaseLabel}" for={id}>
      {#if label}
        <div class="flex justify-between items-center">
          <div>{label}</div>
          <div class="text-xs">
            {#if !isEditing}
              <span class="range-value" 
                on:click={toggleEdit} 
                aria-hidden      
                on:keydown={()=>{}}
              >
                {valueParsed}
              </span>
            {:else}
        <input
          class="range-value-input border-none outline-none text-center text-xs"
          value={valueParsed}
          bind:this={inputRef}  
          on:blur={toggleEdit}
          on:change={handleValueChange}
          on:focus={selectValue}
        />
            {/if}
              <span> / {max}</span>
          </div>
        </div>
      {/if}
      <slot />
    </label>
  {/if}

  <!-- Content -->
  <div class="range-content {cBaseContent}">
    <!-- Input -->
    <input
      type="range"
      {id}
      {name}
      class="range-slider-input {classesInput}"
      list="tickmarks-{id}"
      aria-label={label}
      {min}
      {max}
      {step}
      bind:this={sliderRef}
      bind:value
      on:click
      on:change
      on:input
      on:blur
      {...prunedRestProps()}
    />

    <!-- Tickmarks -->
    {#if ticked && tickmarks && tickmarks.length}
      <datalist id="tickmarks-{id}" class="range-slider-ticks">
        {#each tickmarks as tm}
          <option value={tm} label={tm}></option>
        {/each}
      </datalist>
    {/if}
  </div>

  <!-- Slot: Trail -->
  {#if $$slots.trail}<div class="range-slider-trail"><slot name="trail" /></div>{/if}
</div>
<style>
:global(.range-value-input) {
  display: inline !important;
  padding: 0; 
  text-align: right !important;
  width: auto; 
  border: none !important;
  outline: none !important;
  background: transparent; 
  overflow: hidden !important;
}
</style>